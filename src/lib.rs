#![deny(clippy::missing_docs_in_private_items)]

//! This library is for generating LSynth audio streams.

pub mod waveform;
mod channel;

use crate::channel::ChannelState;

/// The different types of commands that can be sent to channels. The first parameter of each variant is usually a channel index.
#[derive(Clone)]
pub enum Command {
	/// An instruction to set the waveform of the channel.
	///
	/// | Index | Type           |
	/// |---|----------------|
	/// | 0 | Sine           |
	/// | 1 | Triangle       |
	/// | 2 | Rectified Sine |
	/// | 3 | Saw            |
	/// | 4 | Square         |
	/// | 5 | Pulse          |
	/// | 6 | Noise          |
	/// | 7 | Custom         |
	SetWaveform(usize),
	/// An instruction to set the frequency of the channel in hertz.
	SetFrequency(f32),
	/// An instruction to set the amplitude of the channel on a scale of 0..1
	SetAmplitude(f32),
	/// An instruction to set the panning of the channel on a scale of -1..1
	SetPanning(f32),
	/// An instruction to change the custom waveform stored in the channel.
	SetCustomWaveform([f32; waveform::CUSTOM_WIDTH]),
	/// An instruction to set the phase of a waveform directly.
	SetPhase(f32),
	
	/// An instruction to change the amplitude of the channel instantly, instead of softly.
	ForceSetAmplitude(f32),
	/// An instruction to change the panning of the channel instantly, instead of softly.
	ForceSetPanning(f32),
	
	/// An instruction to gradually change the frequency of the channel from its current state to a target state with the specified rate of change.
	FrequencySlide(f32, f32),
	/// An instruction to gradually change the amplitude of the channel from its current state to a target state with the specified rate of change.
	AmplitudeSlide(f32, f32),
	/// An instruction to gradually change the panning of the channel from its current state to a target state with the specified rate of change.
	PanningSlide(f32, f32),
}

/// The current state of the LSynth chip.
pub struct ChipState {
	/// The states of all the channels currently operated by LSynth.
	channels: Vec<ChannelState>,
	/// The number of samples that have yet to be accounted for during this tick cycle.
	wait_samples: f32,
	/// Details how this chip is intended to operate.
	parameters: ChipParameters,
}

/// Parameters detailing how an LSynth chip is intended to operate.
pub struct ChipParameters {
	/// The samplerate in hertz.
	samplerate: usize,
	/// Seconds per sample
	timestep: f32,
	/// The global amplitude of this chip on a scale of 0..1. Affects all channels.
	amplitude: f32,
	/// How many samples are in a tick.
	tick_samples: f32,
}

impl ChipParameters {
	/// Creates a new set of chip parameters. Tick rate is ticks per second.
	pub fn new(samplerate: usize, amplitude: f32, tick_rate: f32) -> ChipParameters {
		ChipParameters {
			samplerate,
			timestep: 1.0/(samplerate as f32),
			amplitude,
			
			tick_samples: ChipState::convert_tick_rate(samplerate, tick_rate),
		}
	}
	
	/// Changes the time it takes for a tick to elapse.
	pub fn set_tick_rate(&mut self, tick_rate: f32) {
		self.tick_samples = ChipState::convert_tick_rate(self.samplerate, tick_rate)
	}
}

impl ChipState {
	/// Creates a new LSynth chip.
	pub fn new(channel_count: usize, parameters: ChipParameters) -> ChipState {
		ChipState {
			channels: (0..channel_count).map(|_| ChannelState::new()).collect(),
			wait_samples: 0.0,
			parameters
		}
	}
	
	/// Converts from ticks per second to samples per tick.
	fn convert_tick_rate(samplerate: usize, tick_rate: f32) -> f32 {
	 	(samplerate as f64 / tick_rate as f64) as f32
	}
	
	/// Compiles samples from every channel into a single stereo track.
	fn get_sample(channels: &[ChannelState], parameters: &ChipParameters) -> (f32, f32) {
		
		let mut left_sample = 0.0;
		let mut right_sample = 0.0;
		
		for channel in channels.iter() {
			let (channel_left_sample, channel_right_sample) = channel.sample();
			left_sample += channel_left_sample;
			right_sample += channel_right_sample;
		};
		
		(left_sample * parameters.amplitude, right_sample * parameters.amplitude)
	}
	
	/// Fills an array slice with interlaced stereo samples generated by the chip.
	pub fn generate(&mut self, buffer: &mut [f32], mut request_callback: impl FnMut(&mut ChipState)) -> core::result::Result<(), String> {
		let samples = buffer.len();
		
		for sample in (0..samples).step_by(2) {
			if self.wait_samples > 0.0 {
				self.wait_samples -= 1.0;
			}
			else {
				for channel in &mut self.channels {
					channel.execute_commands()?;
				}
				self.tick();
				request_callback(self);
			}
			
			let (left_sample, right_sample) = ChipState::get_sample(&self.channels, &self.parameters);
			
			for i in 0..self.channels.len() {
				self.channels[i].advance(self.parameters.timestep);
			}
			
			buffer[sample] = left_sample;
			buffer[sample + 1] = right_sample;
		};
		
		Ok(())
	}
	
	/// Inserts a new command into the chip queue to be executed by the channels.
	pub fn queue_command(&mut self, command: Command, channel: usize) {
		self.channels[channel].command_buffer.push_back(command);
	}
	
	/// Increases ```wait_samples``` by the number of samples it takes for a tick to elapse.
	fn tick(&mut self) {
		self.wait_samples += self.parameters.tick_samples;
	}
}