#![deny(clippy::missing_docs_in_private_items)]

//! This library is for generating LSynth audio streams.

pub mod waveform;
mod channel;
pub mod errors;

use channel::ChannelState;
use errors::{InvalidChannelError, LSynthError, UnevenBufferSliceError};

/// The different types of commands that can be sent to channels.
#[derive(Clone)]
#[repr(C)]
pub enum Command {
	/// An instruction to set the waveform of the channel.
	///
	/// | Index | Type              |
	/// |---|----------------|
	/// | 0 | Sine           |
	/// | 1 | Triangle       |
	/// | 2 | Rectified Sine |
	/// | 3 | Saw            |
	/// | 4 | Square         |
	/// | 5 | Pulse          |
	/// | 6 | Noise          |
	/// | 7 | Custom         |
	SetWaveform(usize),
	/// An instruction to set the frequency of the channel in hertz.
	SetFrequency(f32),
	/// An instruction to set the amplitude of the channel on a scale of 0..1
	SetAmplitude(f32),
	/// An instruction to set the panning of the channel on a scale of -1..1
	SetPanning(f32),
	/// An instruction to change the custom waveform stored in the channel.
	SetCustomWaveform([f32; waveform::CUSTOM_WIDTH]),
	/// An instruction to set the phase of a waveform directly.
	SetPhase(f32),
	
	/// An instruction to change the amplitude of the channel instantly, instead of softly.
	ForceSetAmplitude(f32),
	/// An instruction to change the panning of the channel instantly, instead of softly.
	ForceSetPanning(f32),
	
	/// An instruction to gradually change the frequency of the channel from its current state to a target state with the specified rate of change.
	FrequencySlide(f32, f32),
	/// An instruction to gradually change the amplitude of the channel from its current state to a target state with the specified rate of change.
	AmplitudeSlide(f32, f32),
	/// An instruction to gradually change the panning of the channel from its current state to a target state with the specified rate of change.
	PanningSlide(f32, f32),
}

/// The current state of the LSynth chip.
pub struct ChipState {
	/// The states of all the channels currently operated by LSynth.
	channels: Vec<ChannelState>,
	/// Details how this chip is intended to operate.
	parameters: ChipParameters,
	/// The fractional error that has accumulated between how many samples need to be played in a given tick, and how many actually were.
	tick_error: f32,
}

/// Parameters detailing how an LSynth chip is intended to operate.
pub struct ChipParameters {
	/// The samplerate in hertz.
	samplerate: usize,
	/// Seconds per sample
	timestep: f32,
	/// The global amplitude of this chip on a scale of 0..1. Affects all channels.
	amplitude: f32,
	/// The number of samples there are in a single tick.
	tick_rate: f32,
	/// The number of samples there are in a single tick.
	tick_frames: f32,
}

impl ChipParameters {
	/// Creates a new set of chip parameters. Tick rate is ticks per second.
	pub fn new(samplerate: usize, amplitude: f32, tick_rate: f32) -> ChipParameters {
		ChipParameters {
			samplerate,
			timestep: 1.0/(samplerate as f32),
			amplitude,
			tick_rate,
			tick_frames: samplerate as f32 / tick_rate
		}
	}
	
	/// Converts the from ticks per second to samples per tick.
	fn update_tick_frames(&mut self) {
	 	self.tick_frames = self.samplerate as f32 / self.tick_rate
	}
	
	/// Sets the samplerate of the chip in hertz.
	pub fn set_sample_rate(&mut self, samplerate: usize) {
		self.samplerate = samplerate;
		self.timestep = 1.0/(samplerate as f32);
		self.update_tick_frames();
	}
	
	/// Sets the tick rate of the chip in hertz.
	pub fn set_tick_rate(&mut self, tick_rate: f32) {
		self.tick_rate = tick_rate;
		self.update_tick_frames();
	}
	
	/// Returns the number of samples in a single tick.
	pub fn get_tick_frames(&self) -> f32 {
	 	self.tick_frames
	}
}

impl ChipState {
	/// Creates a new LSynth chip.
	pub fn new(channel_count: usize, parameters: ChipParameters) -> ChipState {
		ChipState {
			channels: (0..channel_count).map(|_| ChannelState::new()).collect(),
			parameters,
			tick_error: 0.0,
		}
	}
	
	/// Fills an array slice with interlaced stereo samples generated by the chip, then returns how much of the buffer it filled.
	pub fn generate(&mut self, buffer: &mut [f32]) -> Result<usize, LSynthError> {
		//use rayon::prelude::*;
		
		if buffer.len() % 2 != 0 {
			return Err(LSynthError::UnevenBufferSlice(UnevenBufferSliceError{slice_length: buffer.len()}));
		}
		
		// Don't want to have to borrow this.
		let timestep = self.parameters.timestep;
		
		let tick_frames = self.parameters.get_tick_frames();
		let tick_error_whole = self.tick_error.floor();
		
		// How many frames we want to generate.
		let tick_frame_count = ((tick_frames).floor() + tick_error_whole) as usize;
		// Discard the non-fractional part once it's been accounted for in tick_frame_count.
		self.tick_error -= tick_error_whole;
		
		// How many frames we actually CAN generate.
		let frames_to_generate = tick_frame_count.min(buffer.len() / 2);
		
		// Generate from each channel on its own thread.
		let frame_vecs: Vec<Vec<(f32, f32)>> = self.channels.iter_mut()
			.map(|channel| {
				let mut frames = vec![(0.0, 0.0); frames_to_generate];
				for value in frames.iter_mut() {
					*value = channel.sample();
					channel.advance(timestep);
				}
				frames
			})
			.collect();
			
		// Iterating over frame_vecs would give us access to one channel at a time, which is not helpful,
		// so instead we're iterating over the slice of the buffer we intend to fill.
		for (i, frame) in buffer.chunks_mut(2).enumerate() {
			frame[0] = 0.0;
			frame[1] = 0.0;
			
			for channel in frame_vecs.iter() {
				let (l, r) = channel[i];
				frame[0] += l * self.parameters.amplitude;
				frame[1] += r * self.parameters.amplitude;
			}
		}
		
		// Adds only the fractional part of tick_frames.
		self.tick_error += tick_frames - tick_frames.floor();
		
		Ok(frames_to_generate)
	}
	
	/// Inserts a new command into the chip queue to be executed by the channels.
	pub fn send_command(&mut self, command: Command, channel: usize) -> Result<(), LSynthError> {
		if channel < self.channels.len() {
			self.channels[channel].execute_command(command)?;
			Ok(())
		}
		else {
			Err(LSynthError::InvalidChannel(InvalidChannelError {
				max_channels_of_chip: self.channels.len(),
				attempted_channel: channel,
			}))
		}
	}
}

/// Initiates a new LSynth chip
#[no_mangle]
pub extern "C" fn ls_init(channel_count: usize, samplerate: usize, amplitude: f32, tick_rate: f32) -> *mut ChipState {
	Box::into_raw(Box::new(ChipState::new(channel_count, ChipParameters::new(samplerate, amplitude, tick_rate))))
}

/// Generates audio with the provided chip
/// # Safety
/// chip_state must be a valid ChipState generated from the ls_init function.
/// buffer_ptr must point to the first f32 in an array, and buffer_len must be the length of that array.
#[no_mangle]
pub unsafe extern "C" fn ls_generate(chip_state: *mut ChipState, buffer_ptr: *mut f32, buffer_len: usize, buffer_start: usize) -> usize {
	let mut chip_state = Box::from_raw(chip_state);
	let buffer = std::slice::from_raw_parts_mut(buffer_ptr, buffer_len);
	
	chip_state.generate(&mut buffer[buffer_start..]).unwrap()
}

/// Inserts a command into the provided chip_state
/// # Safety
/// chip_state must be a valid ChipState generated from the ls_init function.
#[no_mangle]
pub unsafe extern "C" fn ls_send_command(chip_state: *mut ChipState, command: Command, channel: usize) {
	let mut chip_state = Box::from_raw(chip_state);
	
	chip_state.send_command(command, channel).unwrap();
}

/// Returns the number of samples that are in a single tick.
/// # Safety
/// chip_state must be a valid ChipState generated from the ls_init function.
#[no_mangle]
pub unsafe extern "C" fn ls_get_tick_frames(chip_state: *mut ChipState) -> f32 {
	let chip_state = Box::from_raw(chip_state);
	chip_state.parameters.get_tick_frames()
}