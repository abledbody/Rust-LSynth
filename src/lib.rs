#![deny(clippy::missing_docs_in_private_items)]

//! This library is for generating LSynth audio streams.

pub mod waveform;
mod channel;
pub mod errors;

use channel::ChannelState;
use errors::{InvalidChannelError, LSynthError};

/// The different types of commands that can be sent to channels.
#[derive(Clone)]
pub enum Command {
	/// An instruction to set the waveform of the channel.
	///
	/// | Index | Type              |
	/// |---|----------------|
	/// | 0 | Sine           |
	/// | 1 | Triangle       |
	/// | 2 | Rectified Sine |
	/// | 3 | Saw            |
	/// | 4 | Square         |
	/// | 5 | Pulse          |
	/// | 6 | Noise          |
	/// | 7 | Custom         |
	SetWaveform(usize),
	/// An instruction to set the frequency of the channel in hertz.
	SetFrequency(f32),
	/// An instruction to set the amplitude of the channel on a scale of 0..1
	SetAmplitude(f32),
	/// An instruction to set the panning of the channel on a scale of -1..1
	SetPanning(f32),
	/// An instruction to change the custom waveform stored in the channel.
	SetCustomWaveform([f32; waveform::CUSTOM_WIDTH]),
	/// An instruction to set the phase of a waveform directly.
	SetPhase(f32),
	
	/// An instruction to change the amplitude of the channel instantly, instead of softly.
	ForceSetAmplitude(f32),
	/// An instruction to change the panning of the channel instantly, instead of softly.
	ForceSetPanning(f32),
	
	/// An instruction to gradually change the frequency of the channel from its current state to a target state with the specified rate of change.
	FrequencySlide(f32, f32),
	/// An instruction to gradually change the amplitude of the channel from its current state to a target state with the specified rate of change.
	AmplitudeSlide(f32, f32),
	/// An instruction to gradually change the panning of the channel from its current state to a target state with the specified rate of change.
	PanningSlide(f32, f32),
}

/// The current state of the LSynth chip.
pub struct ChipState {
	/// The states of all the channels currently operated by LSynth.
	channels: Vec<ChannelState>,
	/// The number of samples that have yet to be accounted for during this tick cycle.
	wait_frames: f32,
	/// Details how this chip is intended to operate.
	parameters: ChipParameters,
}

/// Parameters detailing how an LSynth chip is intended to operate.
pub struct ChipParameters {
	/// The samplerate in hertz.
	samplerate: usize,
	/// Seconds per sample
	timestep: f32,
	/// The global amplitude of this chip on a scale of 0..1. Affects all channels.
	amplitude: f32,
	/// How many samples are in a tick.
	tick_samples: f32,
}

impl ChipParameters {
	/// Creates a new set of chip parameters. Tick rate is ticks per second.
	#[no_mangle]
	pub fn new(samplerate: usize, amplitude: f32, tick_rate: f32) -> ChipParameters {
		ChipParameters {
			samplerate,
			timestep: 1.0/(samplerate as f32),
			amplitude,
			
			tick_samples: ChipState::convert_tick_rate(samplerate, tick_rate),
		}
	}
	
	/// Changes the time it takes for a tick to elapse.
	#[no_mangle]
	pub fn set_tick_rate(&mut self, tick_rate: f32) {
		self.tick_samples = ChipState::convert_tick_rate(self.samplerate, tick_rate)
	}
}

/// The signature for a callback, executed once a tick has been fully evaluated.
type RequestCallback = fn(&mut ChipState);

impl ChipState {
	/// Creates a new LSynth chip.
	#[no_mangle]
	pub fn new(channel_count: usize, parameters: ChipParameters) -> ChipState {
		ChipState {
			channels: (0..channel_count).map(|_| ChannelState::new()).collect(),
			wait_frames: 0.0,
			parameters
		}
	}
	
	/// Converts from ticks per second to samples per tick.
	fn convert_tick_rate(samplerate: usize, tick_rate: f32) -> f32 {
	 	(samplerate as f64 / tick_rate as f64) as f32
	}
	
	/// Fills an array slice with interlaced stereo samples generated by the chip.
	#[no_mangle]
	pub fn generate(&mut self, buffer: &mut [f32], request_callback: RequestCallback) {
		use rayon::prelude::*;
		
		// Don't wanna have to borrow this.
		let timestep = self.parameters.timestep;
		
		// Index for the beginning of the next tick.
		let mut sample_index = 0;
		
		while sample_index < buffer.len() {
			// wait_frames could be fractional, but we want to generate an integer number of frames.
			let wait_frames_int = self.wait_frames as usize;
			
			let remaining_frames = (buffer.len() - sample_index) / 2;
			let complete_tick = wait_frames_int <= remaining_frames;
			
			// Different from remaining_frames. We only want to generate one tick at a time,
			// which could easily be more or less than the remaining requested frames.
			let frames_to_generate = if complete_tick {
				wait_frames_int
			}
			else {
				remaining_frames
			};
			
			// Generate from each channel on its own thread.
			let frame_vecs: Vec<Vec<(f32, f32)>> = self.channels.par_iter_mut()
				.map(|channel| {
					let mut frames = vec![(0.0, 0.0); frames_to_generate];
					for value in frames.iter_mut() {
						*value = channel.sample();
						channel.advance(timestep);
					}
					frames
				})
				.collect();
			
			// Iterating over frame_vecs would give us access to one channel at a time, which is not helpful,
			// so instead we're iterating over the slice of the buffer we intend to fill.
			for (i, frame) in buffer[sample_index..sample_index + frames_to_generate * 2].chunks_mut(2).enumerate() {
				frame[0] = 0.0;
				frame[1] = 0.0;
				
				for channel in frame_vecs.iter() {
					let (l, r) = channel[i];
					frame[0] += l * self.parameters.amplitude;
					frame[1] += r * self.parameters.amplitude;
				}
			}
			
			sample_index += wait_frames_int * 2;
			self.wait_frames -= frames_to_generate as f32;
			
			// We could actually end up not generating anything for this tick if we don't put the callback at the end of the loop.
			// This would behave as though the commands had not been parsed.
			if complete_tick {
				request_callback(self);
				self.tick();
			}
		}
	}
	
	/// Inserts a new command into the chip queue to be executed by the channels.
	#[no_mangle]
	pub fn send_command(&mut self, command: Command, channel: usize) -> Result<(), LSynthError> {
		if channel < self.channels.len() {
			self.channels[channel].execute_command(command)?;
			Ok(())
		}
		else {
			Err(LSynthError::InvalidChannel(InvalidChannelError {
				max_channels_of_chip: self.channels.len(),
				attempted_channel: channel,
			}))
		}
	}
	
	/// Increases ```wait_samples``` by the number of samples it takes for a tick to elapse.
	fn tick(&mut self) {
		self.wait_frames += self.parameters.tick_samples;
	}
}
